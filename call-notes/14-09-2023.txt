Introdução
    * Nas diferenças de linearidade no Linear Haskell para outros, mencionar um
      ponto grande sobre laziness
Background
    * Remover subsecção dos GADTs, porque não é diretamente relevante para o nosso trabalho
    * Em vez de dizer que temos \beta-reduction diferentes, dizer que "a forma rigorosa de explicar isto" é com operational semantics e definir beta redução
    * Adicionar para o call-by-value que o `v` is a value
    * No call-by-need adicionar as regras que permitem avaliar o e dentro da expressão (tirar do paper do Phil Wadler)
    * Traduzir o $f(\bot) = \bot$ - função aplicada a coisa que não termina não termina em call by value
    * Adicionar paragrafo sobre não dar para perceber a ordem de avaliação e se ou não algo vem a ser avaliado, e foreshadowing como isso influencia bastante a linearidade
    * Fundir "Evaluation in Haskell" com a anterior, e ser específico com
        * Thunks, sharing...
        * Nao tenho só lambdas, também construtores e lets
        * Constructores pressupoem que os argumentos dos construtores
        * Apontar para a prox secção
3
3.1
    * Remover secondary goal, nope, é bem primário DONE
    * functional pseudo-language -> haskell like language DONE
    * mudar eager evaluation para eager semantics e lazy evaluation para lazy semantics DONE
    * "this section helps the reader build" -> we now illustrate semantic ... to build intuition...
    * still used linearly semantically -> still used semantically linearly DONE
    * remover os "sumarios" headers e a frase a introduzir
    * recursive lets: terminar items com pontos finais DONE
    * Mudar o exemplo do linearity semantically que esta errado para
        * Laranja (Apresentar la em cima)
        * Mudar a escrita do exemplo
3.2
    Completar
3.3.
    Standard preservation e such
    Varios lemmas de substitutição que caracterizam as minhas variaveis
    Falar das minhas assumptions; Extrair o texto das assumptions, falar do porque e como são usadas e pq é valido, e dizer pq não provamos e q é future work
        (Assumption 3 pode-se demonstrar)
    Optimisations
        Pequeno preamble, programa fonte esta bem tipificado, optimizaçao produz programa que tipifica
        Fazer listagem das regras antes de as enunciar

Implementação
    - Falar de syntax directed
    - O que não fica nas regras e o que implementamos
    - Falar melhor de split-by-need
-
Validation da tese
Coisas que não consigo validar?
Não conseguimos validar tudo

