
\begin{figure}[h]
\begin{framed}
\small
\[
\begin{array}{c}
    \judgment{\Gamma \vdash e : \sigma}
\\[1em]
    \infer*[right=($Weaken_\omega$)]
    {\Gamma \vdash e : \varphi}
    {\Gamma , x{:}_\omega \sigma \vdash e : \varphi}
\qquad
    \infer*[right=($Weaken_\Delta$)]
    {\Gamma \vdash e : \varphi}
    {\Gamma , x{:}_\Delta \sigma \vdash e : \varphi}
\\[1em]
    \infer*[right=($Contract_\omega$)]
    {\Gamma , x{:}_\omega \sigma, x{:}_\omega \sigma \vdash e : \varphi}
    {\Gamma , x{:}_\omega \sigma \vdash e : \varphi}
\qquad
    \infer*[right=($Contract_\Delta$)]
    {\Gamma , x{:}_\Delta \sigma, x{:}_\Delta \sigma \vdash e : \varphi}
    {\Gamma , x{:}_\Delta \sigma \vdash e : \varphi}
\\[1em]
    \infer*[right=($Var_1$)]
    { }
    {\cdot, x{:}_1 \sigma \vdash x : \sigma}
\qquad
    \infer*[right=($Var_\omega$)]
    { \forall y{:}_\pi\varphi \in \Gamma .~\pi \neq 1 }
    {\Gamma, x{:}_\omega \sigma \vdash x : \sigma}
\qquad
    \infer*[right=($Var_\Delta$)]
    { }
    {\Delta , x{:}_\Delta \sigma \vdash x : \sigma}
\\[1em]
    \infer*[right=($\Lambda I$)]
    {\Gamma, p \vdash e : \sigma \and p \notin \Gamma}
    {\Gamma \vdash \Lambda p.~e : \forall p. \sigma}
\qquad
    \infer*[right=($\Lambda E$)]
    {\Gamma \vdash e : \forall p.~\sigma \and \Gamma \vdash_{mult} \pi}
    {\Gamma \vdash e~\pi : \sigma[\pi/p]} % ROMES:TODO: Subsittution the other way around?
\\[1em]
    \infer*[right=($\lambda I$)]
    {\Gamma, x{:}_\pi\sigma \vdash e : \varphi}
    {\Gamma \vdash \lambda x{:}_\pi\sigma.~e : \sigma \to_\pi \varphi}
\qquad
    \infer*[right=($\lambda E$)]
    {\Gamma \vdash e : \varphi \to_\pi \sigma \and \Gamma' \vdash e' : \varphi}
    {\Gamma,\Gamma' \vdash e~e' : \sigma}
% ROMES: Note that for both Let and LetRec the \Delta env only has linear
    % variables by construction; usage environments only record linear
    % variables.
% ROMES:TODO: Como dizer que o \Delta são todas as variáveis lineares que
    % necessárias para tipificar "e"?
\\[1em]
    \infer*[right=($Let$)]
    {\Gamma, \Delta, x{:}_\Delta\sigma \vdash e' : \varphi
    \and
    \Gamma', \Delta \vdash e : \sigma}
    {\Gamma, \Gamma', \Delta \vdash \llet{x{:}_{\Delta}\sigma = e}{e'} : \varphi}
    % em alternativa a isto que está errado (separar o \Gamma em \Gamma, \Delta)
    % \infer*[right=($Let_{Wrong}$)]
    % {\Gamma, x{:}_\Delta\sigma_1 \vdash e : \sigma_2 \and \Delta \vdash u : \sigma_1}
    % {\Gamma,\Delta \vdash \llet{x{:}_\Delta\sigma_1 = u}{e} : \sigma_2}
\\[1em]
    \infer*[right=($LetRec$)]
    {\Gamma, \overline{x{:}_{\Delta}\sigma} \vdash e : \varphi
    \and
    \overline{\Gamma', \Delta, \overline{x{:}_{\Delta}\sigma} \vdash e' : \sigma}
    }
    {\Gamma, \overline{\Gamma'}, \overline{\Delta} \vdash \lletrec{\overline{x{:}_\Delta\sigma = e'}}{e} : \varphi}
\\[1em]
    \infer*[right=($Case$)]
  { \Gamma \vdash e_1 : \sigma \and
  \overline{\Gamma', z{:}_{\Delta_i}\sigma \vdash_{alt} \rho_i \to e_i :_{\Delta_i} \sigma \Rightarrow \varphi} }
    {\Gamma, \Gamma' \vdash \ccase{e_1}{z{:}_{\overline{\Delta}^n}\sigma~\{\overline{\rho_i\to e_i}^n\}} : \varphi}
  \\[1em]
  
    \judgment{\Gamma \vdash_{alt} \rho \to e :_\Delta \sigma \Rightarrow \varphi}
\\[1em]
    \infer*[right=$(Alt)$]
    { K:\overline{\sigma\to_\pi}~T~\overline{p}\in\Gamma \and \Gamma,
  \overline{x{:}_\pi\sigma} \vdash e : \varphi
   \and \Delta = \overline{x{:}_\pi\sigma}  \!\upharpoonright_1 }
    {\Gamma \vdash_{alt} K~\overline{x{:}_\pi\sigma} \to e :_\D T~\overline{p} \Rightarrow \varphi}
\qquad
    \infer*[right=$(Alt_\_)$]
    { \Gamma \vdash e : \varphi \and \D = \cdot }
    {\Gamma \vdash_{alt} \_ \to e :_\D  T~\overline{p} \Rightarrow \varphi}
\\[1em]
    \judgment{\Gamma \vdash_{mult} \pi}
\\[1em]
    \infer*[right=$(1)$]
    { }
    {\Gamma \vdash 1}
\qquad
    \infer*[right=$(\omega)$]
    { }
    {\Gamma \vdash \omega}
\qquad
    \infer*[right=$(\rho)$]
    { }
    {\Gamma, \rho \vdash \rho}
\\[1em]
\begin{array}{cc}
\judgment{\Gamma \vdash decl : \Gamma'} & \judgment{\Gamma \vdash pgm : \sigma}\\
\\[0.05em]
\infer*[right=$(Data)$]{ }{\Gamma \vdash (\datatype{T~\overline{p}}{\overline{K:\sigma}}) : (\overline{K:\sigma}) } &
\infer*[right=$(Pgm)$]{\overline{\Gamma \vdash decl:\Gamma_d} \and \Gamma = \Gamma_0,\overline{\Gamma_d}\\\\ \Gamma~\mathsf{is~consistent?} \and \Gamma \vdash e : \sigma}{\Gamma_0 \vdash \overline{decl}; e : \sigma}
\end{array}
\end{array}
\]
\end{framed}
\caption{Linear Core* Typing Rules}
\label{linear-core-typing-rules}
\end{figure}

