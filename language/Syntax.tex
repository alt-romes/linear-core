
\begin{figure}[h]
\begin{framed}
\[
\begin{array}{l}
%
\textbf{Types} \\
\begin{array}{lcll}
    \varphi,\sigma  & ::=  & T~\overline{p}         & \textrm{Datatype} \\
                    & \mid & \varphi \to_\pi \sigma & \textrm{Function with multiplicity}\\
                    & \mid & \forall p.~\varphi     & \textrm{Multiplicity universal scheme}\\
                   % TODO: Eventually Coercions
\end{array}\\\\
%
\textbf{Terms}\\
\begin{array}{lcll}
    u                & ::=  & x,y,z \mid K                                                     & \textrm{Variables and data constructors}\\
    e                & ::=  & u                                                                & \textrm{Term atoms}\\
                     & \mid & \Lambda p.~e~\mid~e~\pi                                          & \textrm{Multiplicity abstraction/application}\\
                     & \mid & \lambda x{:}_\pi\sigma.~e~\mid~e_1~e_2                           & \textrm{Term abstraction/application}\\
                     & \mid & \llet{x{:}_\Delta\sigma = e_1}{e_2}                              & \textrm{Let} \\
                     & \mid & \lletrec{\overline{x{:}_\Delta\sigma = e_1}}{e_2}                & \textrm{Recursive Let} \\
                     & \mid & \ccase{e_1}{z{:}_{\overline{\Delta}}\sigma~\{\overline{\rho\to e_2}\}} & \textrm{Case} \\
                     &      &                                                                  & \\
%    p               & ::=  & K~\overline{b{:}\kappa}~\overline{x{:}\sigma}                    & \textrm{Pattern} \\
    \rho             & ::=  & K~\overline{x{:}_\pi\sigma} \mid \_                              & \textrm{Pattern and wildcard} \\
% Currently we don't care about the existential multiplicity variables, but later on we might
\end{array}\\\\
%
\textbf{Environments}\\
\begin{array}{lcll}
  \Gamma   & ::=  & \cdot                                 & \textrm{Empty environment} \\
           & \mid & \Gamma,x{:}_\pi\sigma                 & \textrm{Lambda bound variable} \\
           & \mid & \Gamma,x{:}_\Delta\sigma              & \textrm{Let(rec) bound variable}\\
         % & \mid & \Gamma,x{:}_{\overline{\Delta}}\sigma & \textrm{Case bound variables} -- NOPE
           & \mid & \Gamma,K{:}\sigma                     & \textrm{Data constructor}\\
           & \mid & \Gamma,p                              & \textrm{Multiplicity variable}\\
\end{array}\\\\
%
\textbf{Multiplicities}\\
\begin{array}{lcll}
  \pi, \mu & ::= & 1 \mid \omega \mid p \mid \pi + \mu \mid \pi \cdot \mu\\
% We don't use + and cdot yet, but we will
\end{array}\\\\
%
\textbf{Usage Environments}\\
\begin{array}{lcl}
  \Delta & ::= & \cdot \mid \Delta, x{:}_1\sigma \mid \Delta+\Delta' \mid \pi\Delta\\
\end{array}\\\\
%
\textbf{Declarations}\\
\begin{array}{lcl}
  pgm & ::= & \overline{decl}; e \\
  decl & ::= & \datatype{T~\overline{p}}{\overline{K:\overline{\sigma \to_\pi}~T~\overline{p}}}
\end{array}
%
\end{array}
\]
\end{framed}
\caption{Linear Core* Syntax}
\label{linear-core-syntax}
\end{figure}

