@misc{jones1999haskell,
  title={Haskell 98},
  author={Jones, Simon Peyton and Hughes, John and Augustsson, Lennart and Barton, Dave and Boutel, Brian and Burton, Warren and Fasel, Joseph and Hammond, Kevin and Hinze, Ralf and Hudak, Paul and others},
  year={1999},
  publisher={Citeseer}
}


@article{marlow2010haskell,
  title={Haskell 2010 language report},
  author={Marlow, Simon and others},
  year={2010}
}

@article{cite:linearhaskell,
  author    = {Jean{-}Philippe Bernardy and
               Mathieu Boespflug and
               Ryan R. Newton and
               Simon Peyton Jones and
               Arnaud Spiwack},
  title     = {Linear Haskell: practical linearity in a higher-order polymorphic
               language},
  journal   = {CoRR},
  volume    = {abs/1710.09756},
  year      = {2017},
  url       = {http://arxiv.org/abs/1710.09756},
  eprinttype = {arXiv},
  eprint    = {1710.09756},
  timestamp = {Mon, 13 Aug 2018 16:47:41 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1710-09756.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{linearbase,
  title = {{linear-base}},
  author = {{Tweag}},
  howpublished = {\url{https://github.com/tweag/linear-base}},
  note = {Accessed: 2022-11-25}
}

@article{10.1145/1160074.1159811,
author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},
title = {Simple Unification-Based Type Inference for GADTs},
year = {2006},
issue_date = {September 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1160074.1159811},
doi = {10.1145/1160074.1159811},
abstract = {Generalized algebraic data types (GADTs), sometimes known as "guarded recursive data types" or "first-class phantom types", are a simple but powerful generalization of the data types of Haskell and ML. Recent works have given compelling examples of the utility of GADTs, although type inference is known to be difficult. Our contribution is to show how to exploit programmer-supplied type annotations to make the type inference task almost embarrassingly easy. Our main technical innovation is wobbly types, which express in a declarative way the uncertainty caused by the incremental nature of typical type-inference algorithms.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {50–61},
numpages = {12},
keywords = {type inference, generalized algebraic data types}
}

@inproceedings{10.1145/1159803.1159811,
author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},
title = {Simple Unification-Based Type Inference for GADTs},
year = {2006},
isbn = {1595933093},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1159803.1159811},
doi = {10.1145/1159803.1159811},
abstract = {Generalized algebraic data types (GADTs), sometimes known as "guarded recursive data types" or "first-class phantom types", are a simple but powerful generalization of the data types of Haskell and ML. Recent works have given compelling examples of the utility of GADTs, although type inference is known to be difficult. Our contribution is to show how to exploit programmer-supplied type annotations to make the type inference task almost embarrassingly easy. Our main technical innovation is wobbly types, which express in a declarative way the uncertainty caused by the incremental nature of typical type-inference algorithms.},
booktitle = {Proceedings of the Eleventh ACM SIGPLAN International Conference on Functional Programming},
pages = {50–61},
numpages = {12},
keywords = {type inference, generalized algebraic data types},
location = {Portland, Oregon, USA},
series = {ICFP '06}
}

@article{10.1145/3408971,
author = {Serrano, Alejandro and Hage, Jurriaan and Peyton Jones, Simon and Vytiniotis, Dimitrios},
title = {A Quick Look at Impredicativity},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3408971},
doi = {10.1145/3408971},
abstract = {Type inference for parametric polymorphism is wildly successful, but has always suffered from an embarrassing flaw: polymorphic types are themselves not first class. We present Quick Look, a practical, implemented, and deployable design for impredicative type inference. To demonstrate our claims, we have modified GHC, a production-quality Haskell compiler, to support impredicativity. The changes required are modest, localised, and are fully compatible with GHC's myriad other type system extensions.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {89},
numpages = {29},
keywords = {Type systems, constraint-based inference, impredicative polymorphism}
}

@inproceedings{10.1145/3062341.3062357,
author = {Eisenberg, Richard A. and Peyton Jones, Simon},
title = {Levity Polymorphism},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062357},
doi = {10.1145/3062341.3062357},
abstract = {Parametric polymorphism is one of the linchpins of modern typed programming, but it comes with a real performance penalty. We describe this penalty; offer a principled way to reason about it (kinds as calling conventions); and propose levity polymorphism. This new form of polymorphism allows abstractions over calling conventions; we detail and verify restrictions that are necessary in order to compile levity-polymorphic functions. Levity polymorphism has created new opportunities in Haskell, including the ability to generalize nearly half of the type classes in GHC's standard library.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {525–539},
numpages = {15},
keywords = {compilation, polymorphism, unboxed types},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1017/S0956796806006034,
author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
title = {Practical Type Inference for Arbitrary-Rank Types},
year = {2007},
issue_date = {January 2007},
publisher = {Cambridge University Press},
address = {USA},
volume = {17},
number = {1},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796806006034},
doi = {10.1017/S0956796806006034},
abstract = {Haskell's popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types – that is, functions that take polymorphic functions as their arguments. Complete type inference is known to be undecidable for higher-rank (impredicative) type systems, but in practice programmers are more than willing to add type annotations to guide the type inference engine, and to document their code. However, the choice of just what annotations are required, and what changes are required in the type system and its inference algorithm, has been an ongoing topic of research. We take as our starting point a $lambda$-calculus proposed by Odersky and L\"{a}ufer. Their system supports arbitrary-rank polymorphism through the exploitation of type annotations on $lambda$-bound arguments and arbitrary sub-terms. Though elegant, and more convenient than some other proposals, Odersky and L\"{a}ufer's system requires many annotations. We show how to use local type inference (invented by Pierce and Turner) to greatly reduce the annotation burden, to the point where higher-rank types become eminently usable. Higher-rank types have a very modest impact on type inference. We substantiate this claim in a very concrete way, by presenting a complete type-inference engine, written in Haskell, for a traditional Damas-Milner type system, and then showing how to extend it for higher-rank types. We write the type-inference engine using a monadic framework: it turns out to be a particularly compelling example of monads in action. The paper is long, but is strongly tutorial in style. Although we use Haskell as our example source language, and our implementation language, much of our work is directly applicable to any ML-like functional language.},
journal = {J. Funct. Program.},
month = {jan},
pages = {1–82},
numpages = {82}
}

@article{10.1145/227699.227700,
author = {Hall, Cordelia V. and Hammond, Kevin and Peyton Jones, Simon L. and Wadler, Philip L.},
title = {Type Classes in Haskell},
year = {1996},
issue_date = {March 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/227699.227700},
doi = {10.1145/227699.227700},
abstract = {This article defines a set of type inference rules for resolving overloading introduced by type classes, as used in the functional programming language Haskell. Programs including type classes are transformed into ones which may be typed by standard Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to Haskell programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the transformed program.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {mar},
pages = {109–138},
numpages = {30},
keywords = {Haskell, type classes, functional programming, types}
}


@article{10.1145/3473569,
author = {Eisenberg, Richard A. and Duboc, Guillaume and Weirich, Stephanie and Lee, Daniel},
title = {An Existential Crisis Resolved: Type Inference for First-Class Existential Types},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473569},
doi = {10.1145/3473569},
abstract = {Despite the great success of inferring and programming with universal types, their dual—existential types—are much harder to work with. Existential types are useful in building abstract types, working with indexed types, and providing first-class support for refinement types. This paper, set in the context of Haskell, presents a bidirectional type-inference algorithm that infers where to introduce and eliminate existentials without any annotations in terms, along with an explicitly typed, type-safe core language usable as a compilation target. This approach is backward compatible. The key ingredient is to use strong existentials, which support (lazily) projecting out the encapsulated data, not weak existentials accessible only by pattern-matching.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {64},
numpages = {29},
keywords = {type inference, Haskell, existential types}
}

@inproceedings{DBLP:conf/popl/DamasM82,
  author    = {Lu{\'{\i}}s Damas and
               Robin Milner},
  editor    = {Richard A. DeMillo},
  title     = {Principal Type-Schemes for Functional Programs},
  booktitle = {Conference Record of the Ninth Annual {ACM} Symposium on Principles
               of Programming Languages, Albuquerque, New Mexico, USA, January 1982},
  pages     = {207--212},
  publisher = {{ACM} Press},
  year      = {1982},
  url       = {https://doi.org/10.1145/582153.582176},
  doi       = {10.1145/582153.582176},
  timestamp = {Tue, 06 Nov 2018 11:07:43 +0100},
  biburl    = {https://dblp.org/rec/conf/popl/DamasM82.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
